State machine y scheduler:
const int PIN_LED = LED_BUILTIN; รง
int idTareaParpadeo;

void parpadearLed() {
    // Lee el estado actual y lo invierte
    digitalWrite(PIN_LED, !digitalRead(PIN_LED));
}

static bool transicion1 = false;
static bool transicion2 = false;

constexpr auto state = make_state(States::STATE1,
        Transition<States>{States::STATE2, []() { return transicion1; }}
    );

constexpr auto state2 = make_state(States::STATE2,
        Transition<States>{States::STATE1, []() { return transicion2; }}
    );

static constinit auto state_machine = [state,state2]()consteval{
    auto sm = make_state_machine(States::STATE1, state,state2);
    sm.add_enter_action([](){
      transicion1 = false;
      Serial.println("Entro al estado 1");
    },state);

    sm.add_enter_action([](){
      transicion2 = false;
      Serial.println("Entro al estado 2");
    },state2);

    using namespace std::chrono_literals;
    
     sm.add_cyclic_action([](){
        parpadearLed();
        Serial.println("parpadeando led cada 100ms en estado 1");
      }, 100ms, state);

      sm.add_cyclic_action([](){
        parpadearLed();
        Serial.println("parpadeando led cada 500ms en estado 2");
      }, 500ms, state2);

      sm.add_exit_action([](){
            Serial.println("Saliendo de estado 2");
        }, state2);

        sm.add_exit_action([](){
            Serial.println("Saliendo de estado 1");
        }, state);

    return sm;

}();

void setup() {
  Serial.begin(115200);
  pinMode(PIN_LED, OUTPUT);

  idTareaParpadeo = Scheduler::register_task(5000,[](){
    transicion1 = true;
  });

  Scheduler::set_timeout(10000,[](){
      transicion2=true;
  });

   Scheduler::register_task(50, [](){
        state_machine.check_transitions();
    });

  Scheduler::start();

  state_machine.start();

}

void loop() {
  Scheduler::update();
}

Sin mqtt y sin ultrasonidos:
#pragma once
#include <Arduino.h>
#include "StateMachine.hpp"
#include "Data.hpp"
#include "Actuators.hpp"
#include "Sensors.hpp"
#include "MQTT-WIFI.hpp"

class Board
{
  /*State Machine declaration*/
  static inline constexpr auto connecting_state = make_state(General_states::Connecting,
        Transition<General_states>{General_states::Operational, []() { return /*Comms::is_connected()*/true; }}
    );

  static inline constexpr auto operational_state = make_state(General_states::Operational,
        Transition<General_states>{General_states::Fault, []() { return /*!Comms::is_connected()*/false; }}
    );

  static inline constexpr auto fault_state = make_state(General_states::Fault);

  static inline constexpr auto forward_state = make_state(Operational_states::Forward,
        Transition<Operational_states>{Operational_states::Junction_stop, []() { return Sensors::distancia_ultra < 5.0; }}
    );

  static inline constexpr auto junction_stop_state = make_state(Operational_states::Junction_stop,
        Transition<Operational_states>{Operational_states::Junction_forward, []() { return /*Comms::get_auth_flag()*/ true; }}
    );

  // static inline constexpr auto junction_stop_state = make_state(Operational_states::Junction_stop,
  //       Transition<Operational_states>{Operational_states::Junction_forward, []() { return Sensors::distancia_ultra > 6.0; }}
  //   );

  static inline constexpr auto junction_forward_state = make_state(Operational_states::Junction_forward,
      Transition<Operational_states>{Operational_states::Forward, []() { return /*Comms::get_end_flag()*/ true; }}
  );

  static inline constinit auto Nested_state_machine = [forward_state,junction_stop_state,junction_forward_state]()consteval{
    auto sm = make_state_machine(Operational_states::Forward, forward_state,junction_stop_state,junction_forward_state);
    using namespace std::chrono_literals;

    /*--------Forward----------*/

    sm.add_enter_action([](){
      Actuators::set_led_green(true);
      // Comms::set_end_flag(false);
    },forward_state);

    sm.add_cyclic_action([](){
        Actuators::control_loop();
      }, 5ms, forward_state);

    /*--------Junction stop----------*/

    sm.add_enter_action([](){
      Actuators::stop();
      // Comms::send_auth_request();
    },junction_stop_state);

    sm.add_cyclic_action([](){
      static bool toggle = true;
      Actuators::set_led_blue(toggle);
      toggle =!toggle;
    },500ms,junction_stop_state);

    sm.add_cyclic_action([](){
      // Comms::send_auth_request();
    },250ms,junction_stop_state);
    
    sm.add_exit_action([](){
      Actuators::move(Actuators::Direction::Forward,Actuator_data::MAX_SPEED,Actuator_data::MAX_SPEED);
    },junction_stop_state);

    /*--------Junction forward----------*/

    sm.add_enter_action([](){
      Actuators::set_led_blue(true);
      // Comms::set_auth_flag(false);
    },junction_forward_state);

    sm.add_cyclic_action([](){
        Actuators::control_loop();
    }, 5ms, junction_forward_state);

    return sm;
  }();

  static inline constinit auto State_machine = [connecting_state,operational_state,fault_state]()consteval{
    auto sm = make_state_machine(General_states::Connecting, connecting_state,operational_state,fault_state);
    using namespace std::chrono_literals;

    sm.add_enter_action([](){
      Actuators::move(Actuators::Direction::Forward,Actuator_data::MAX_SPEED,Actuator_data::MAX_SPEED);
    },operational_state);

    sm.add_cyclic_action([](){
      static bool toggle = true;
      Actuators::set_led_green(toggle);
      toggle = !toggle;
    },500ms,connecting_state);

    sm.add_enter_action([](){
      Actuators::set_led_red(true);
      Serial.print("Va a fault");
      Actuators::stop();
    },fault_state);

    sm.add_state_machine(Nested_state_machine,operational_state);

    return sm;
  }();

  public: 
  static void start()
  {
    Sensors::init();   
    Actuators::init();
    Scheduler::register_task(1,[](){
      Sensors::read_infrarojo();
    });
    Scheduler::register_task(50,[](){
      Sensors::read_ultrasonido();
    });

    State_machine.start();

    Scheduler::register_task(10,[](){
      State_machine.check_transitions();
      // if(Nested_state_machine.get_current_state()== Operational_states::Junction_forward){
      //     Nested_state_machine.force_change_state(forward_state);
      // }
    });

  }

};